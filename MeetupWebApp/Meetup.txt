==> What I Learnt From that project  <==

=> Search and Filering Meetups 

so the flow when the user search 
#first the user write his search keyword and then type search button
#second in Search Filter ( that i made ) filter if the search keyword is in Events Titles if not then is in Events Descreption 
	if not then is in Events Locations so else (we not found any thing) then i will return the newest events (i will not return an empty page)
	

so we need first to check the fiter results with user search key if returned an empty list (that means maybe the word is out of the context) 
then i will return the newest events.
the below example for that filter (in service)

<code>
	 private async Task<List<Event>> SearchFilter (ApplicationDbContext context , string? searchWord)
        {

            return await context.Events.AsNoTracking().Where(x => (x.BeginDate > DateOnly.FromDateTime(DateTime.Now) 
                                                    || (x.BeginDate == DateOnly.FromDateTime(DateTime.Now) && 
                                                            x.BeginTime >= TimeOnly.FromDateTime(DateTime.Now))) && 
                                            (string.IsNullOrEmpty(searchWord) || x.Title.Contains(searchWord) || x.Description.Contains(searchWord) || x.Location.Contains(searchWord)))
                                            .OrderByDescending(x => x.BeginDate)
                                            .ThenByDescending(x => x.BeginTime)
                                            .ToListAsync();
        }
</code>


so that is basically the filter, it returns the newest events && events title, Descreption and any locations that match that keyword if not
    then return jsut newest events (How) because that condition ** string.IsNullOrEmpty(searchWord) ** 

so how to know if the word is empty and also knowing if there is no events that match the keyword how 
look at this 

<code>
      public async Task<List<EventViewModel>> GetEventsAsync(string searchWord)
        {
            using var context = await Factory.CreateDbContextAsync();

            var events = await SearchFilter(context, searchWord);

            if(events.Count == 0 && !string.IsNullOrEmpty(searchWord))
            {
                searchWord = null;
                events = await SearchFilter(context, searchWord);
            }

            return Mapper.Map<List<EventViewModel>>(events);
        }
</code>

so basically if not returned any events && the searchkey is not empty that means that there is not matches then i will pass null to the filter
and retuen just the newest events by that condition in the filter with that condition ** string.IsNullOrEmpty(searchWord) **
===================================================
=> using the search bar component in layout and also search in the same page not redirect to single page

When integrating the Search Bar inside the main Layout, the goal was to run the search on the same page without redirecting to a different route.
This heavily relies on how the NavigationManager handles URLs and query strings.

How the Flow Works With NavigationManager

When you're on a page like /events and you trigger a search, you might think you need to modify the page’s route to include the query parameter, like:

/events?search={key}


Then you might assume:

“Since I'm navigating to /events?search=key, I must update the route definition to match that pattern.”

But here’s the important part:

NavigationManager Is Smarter Than That

If you call:

NavigationManager.NavigateTo("/events?search=key");


Blazor does not require your page route to explicitly support query strings.
Even if your page only has the route:

@page "/events"


Blazor will still navigate to:

/events?search=key

and the component will load normally — the query string is simply attached to the URL, not part of the routing pattern.

---
so how to use the search bar in layout component and also search 

first of all the search bar is like this 

<code>
    
    <div class="d-flex" role="search">
        <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search" @bind:event=oninput @bind ="SearchWord">
        <button class="btn btn-outline-light" type="button" @onclick="Search">Search</button>
    </div>

</code>

#first so let's define a string for search keyword and bind it with the input  
#second and once the user types search we will handle that search by that method that navigate to the page that displays the events somthing lke that
<code>

     public void Search()
    {
        if (string.IsNullOrEmpty(SearchWord))
            return;

        var Uri = new Uri(NavigationManager.Uri);

        NavigationManager.NavigateTo($"events?search={SearchWord}", forceLoad: true);
    }

</code>

so the navigation manager will navigate to the "/events" page as we told but also holding the query string so it is the basically is the search 

#third go to the events page and recive that key search from the query string how?

by getting the url from the navigation manager and gets the query string 
and then using HttpUtitlity that takes the query string and retuen it wil key value pair and then key the data or the search key for "search" key that we typed in the url 

Fact: if you navigate the any page the Navigation Manager holds the url and if there is query string will hold that thing 
Note that any page you access remeber that Navigation Manager holds the full url so will use it 
in events page the navigation is  holds the query string to that page so we will get the url 

<code>
    @page "/events"

    @*
        Display the Events Here
    *@


    @code 
    {
        public var events = new List<EventViewMode>();

        protected override async Task OnParameterSetAsync()
        {
            // get the url from NavigationManager
            Uri Uri = new(NavigationManager.Uri);

            // Get the query string from the url
            var Query = HttpUtility.ParseQueryString(Uri.Query);

            // and get the Key:value (key of query param name, value query param value)
            // and we know the key that we Naviagte to from the search bar -> "?search=key" are remember that ?
            var QueryParamValue = Query["search"] ?? string.Empty;

            // using the search filter service and gets the events
            events = DiscoverEventsService.GetEvents(QueryParamValue);
        }
    }

</code>

Note that : the NavigationManager is registered as a singleton service that means once you navigate in a page the navigation holds the url even 
you in this page use another service that also use NavigationManager will also holds the same url 
example let imagine that you in search component in layout uses NavigationManager and also in the page uses NavigationManager and also 
in that page you use service that uses also NavigationManager 

so once you navigate to page the NavigationManager.Uri in search component is the same in NavigationManager.Uri in the page also is the same when the service 
uses NavigationManager in the page so the conclusion is the NavigationManager.Uri will be the same in any part of the page (service, layout, ...)
because the page is not stand alone it depends on layout and also services 

so as we saw in the SearchComponent we Navigate To "/events" page but we need to search in the current page means if we in any page that Display data 
we need to search on it not only search in the "/events" page

so the solution is very simple so as we said that the NavigationManager.Uri is will be the same once you navigate to any page 
so there is in Uri class property called "AbsolutePath" that returns the after the url host and before the query string 
that means if the url for example "/events?search=key" -> AbsolutePath = /events

so we will get the url from the navigation manager and get that AbsolutePath and Navigate to it using NavigationManager 

for example if we in page it's route is "/users" 
so in search the component if we once search the Navigate to url will be -> "/users?search=key"
also if we in events page the Navigate Url will be -> "events?search=key" ans so on 

and in each page that display the data instead of displayign from the database directoy 
we get the data based on the searchword that will be passed to us by the NavigationManager 

so the flow is 
we are currently in page it's route is "products"
so that means the NavigationManager have that url "https://host/products"
so once we searched in that page using the searchbar will be naviagted to NavigationManager.NavigateTo($"{AbsolutePath}?search={word}")
and as we said that the AbsolutePath will be products because we in products page so will redirect to the same page that we in but with diffrent url 
instead of just "/products" will be "/products?search=key"
so in that page we will get the data based on the search key only and if it null basically get the all data
so the result is need to get that data for each page displays the data like we did in "/evenst"

there is another problem after render the page the key word is gone after rendering that is also a normal behavior 
so to solve this as we told the navigationMnaagaer Uri is the same in the page or in other component such as service
or layout so

to solve this we bind the searchword in string property in initializing let it the string property 
instead of just bind from the input no 
it inittialzed from the Navigation
so we will do the same process to the get the value amd assign to the string proprty 
in first searcg will be null or empty because there is no search happen the uri is just like this "users"
but after first search the string property that bind to the inpurt will reed the value from the url 
and that after rendering will be exist 
let's talk look 
at this example i implemented this in service 

<code>
        // we know that the "search"
        public async Task<string> GetParamValueAsync (string QueryParam)
        {
            Uri Uri = new(NavigationManager.Uri);

            var Query = HttpUtility.ParseQueryString(Uri.Query);

            var QueryParamValue = Query[QueryParam] ?? string.Empty;

            return QueryParamValue;
        }

</code>

and in the searhc bar component 

<code>

     public string? SearchWord { get; set; }

    protected override async Task OnInitializedAsync()
    {
        SearchWord = await SharedHelper.GetParamValueAsync("search");
    }
    
</code>

SearchWord that is the value we bind in the input 

and also we can use that method to get the searchword in any page

<code>
            events = await DiscoverEventsService.GetEventsAsync(await SharedHelper.GetParamValueAsync("search"));

</code>

==============================
==> Authentication with google OAuth

so that is called OAuth 

// TODO: Complete first Asp.NetCore Security first
what is OAuth ?

How the flow ?

we need first to install Authenrication.Google first 
then adding the clientId and the Client Secret to google be able to determine us
so what google wiil do is simply take the user to register with his google email 
then return to the web application the claims 
then in that case we have the choice if we authenticate the user if cookie then add this claims from google to cookie
if Jwt token then add this claims to the Jwt token

so first in program.cs adding that configuration 

<Code>

    builder.Services.AddAuthentication( op =>
    {
        op.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        op.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
        op.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    })
    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddGoogle(options =>
    {
        options.ClientId = builder.Configuration["Authentication:Google:ClientId"] ?? string.Empty;
        options.ClientSecret = builder.Configuration["Authentication:Google:ClientSecret"] ?? string.Empty;
        options.Scope.Add("profile");
        options.Scope.Add("email");
    });


</Code>

so what is that we set the default authentication schema with the cookie becuase we authenticate the user with cookie 
with google claims 
what is mean by challenging that means we chellange the user to put his information and that role what google
authentication what will do for us 

so that is it the configuration and the set up 

so the package once the user login will send the client id and the client secret and the callback url and is the "signin-google"
here the endpoint is internally in the package will recive the access token and the id token so the middlware internally will get the 
claims from that access token 

then after of collecting the claims the response will be with enpoint you will recive that claims 
and then you can basically use cookies or return jwt token what ever you want

so the flow with the code

so let's imaging we have an blazor frontend and web api 

so in front end the user in some url ckicked the button to signin with google so the frontend will navigate to the url in web api and will add return url to return the same page for the user after login 

<code>

    public void AuthWithExternalProvider(string provider)
    {
        var returnUrl = NavigationManager.Uri;

        var EncodedUrl = HttpUtility.UrlEncode(returnUrl);

        NavigationManager.NavigateTo($"/Authentication/{provider}?returnurl={EncodedUrl}");
    }

    so will navigate to the endpoint /Authentication/{provider}  -> provider that is google on our example and add in Qury string the url


    so in enpoint that recive that request 


    app.MapGet("/Authentication/{provider}", async (HttpContext ctx, string provider) =>
    {
        var returnUrl = ctx.Request.Query["returnurl"].ToString();

        var redirectUrl = "signin-callback";

        if(!string.IsNullOrEmpty(returnUrl))
        {
            redirectUrl = redirectUrl + $"?returnurl={returnUrl}";
        }

        var properties = new AuthenticationProperties() { RedirectUri = redirectUrl };

        await ctx.ChallengeAsync(provider, properties);
    });

</code>

so we get the url

so we in that line  var properties = new AuthenticationProperties() { RedirectUri = redirectUrl };

we configure that after the login and collecting the claims redirect to that url and it is endpoint 

provider is simple string and if Google will simply will be "Google" 


so in that line await ctx.ChallengeAsync(provider, properties); // we tell the context take that request to challenge him
to add his information with that provider (Google) and after login and collectioning the claims redirect to url in properties


so once we challenge  await ctx.ChallengeAsync(provider, properties); the package send to google a post request with the client id and the secret id and also the return url ("signin-google") that url 
will google will send the Access token and the id token and then some internall mideelware will get the data from that access token

and then after all of that the response will be redirected with the endpoint we determine in that line         var properties = new AuthenticationProperties() { RedirectUri = redirectUrl };


so to get the claims that middleware extracted from the access token 

<code>
    
        // remmeber that we add the retun url to the from in the redirect url in the prev endpoint 
        // so the redirect url is /signin-callback and have in quey the return url

    app.MapGet("/signin-callback", async (HttpContext ctx) =>
    {
        var returnUrl = ctx.Request.Query["returnurl"].ToString();

        var DecodedUrl = HttpUtility.UrlDecode(returnUrl);

        var result = await ctx.AuthenticateAsync(GoogleDefaults.AuthenticationScheme);

        if(result.Succeeded && result.Principal is not null)
        {
            await ctx.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, result.Principal);

            if(!string.IsNullOrEmpty(DecodedUrl))
                ctx.Response.Redirect(DecodedUrl);

            return;
        }

        ctx.Response.Redirect("/");
        // TODO: return ErrorMessage
        return;
    });

    // so that in that line   var result = await ctx.AuthenticateAsync(GoogleDefaults.AuthenticationScheme);
    we tell that result of the authentication of that schema is successed where the claims 
    so that contains the status of the authentication and also have the claims that colleced in the internall middelware 

    so you can here get the claism and if web api return the acces token and refresh token or if web application juts create cookei with that claism 
    and then sign in the claims 
    and then redirect the current request to the redirect url in the from by that line
    
            if(!string.IsNullOrEmpty(DecodedUrl))
                ctx.Response.Redirect(DecodedUrl);


    so notice that we encode and decode the url using HttpUtility




</code>


the correct flow is simply 
the defualt behavior is 
when the user hit accept with his email with google 
google send a request to the redirect url is by default signin-google and then before the request arrives to to the 
redirect url or endpoint 
thtere is OAuth Middleware is like afilter before gets the endpoint it take the authorization code and then make arequest with the authorization code 
to recive the access token and the Id token and then the middelware gets the user claims from that access token after validate the token 
and then make the claimsprincipal and put the claims in context.User and Contxt.AuthenticateAsync(Schma)
so the reuquest arrives to the endpoint with claims is ready 
so the defualt behavior if the redirect Url is signin-google then the middleware after puting claims then will make cookie with that claims 
and that is it not store users and the whole stuff so 
remember the middleware who is that create the cookie not the signin-google
if you make or define the dericet url will not arrives to signin-google the defualt will arrive to the redirect url you define 
so example for that is 

before make user get google auth Ui 
we make that

    var properties = new AuthenticationProperties() { RedirectUri = redirectUrl };

    await ctx.ChallengeAsync(provider, properties);

    and then pass it with the provider 
        await ctx.ChallengeAsync(provider, properties);
that means will make arequest with the client id and secret and also the redirect url you define 
so when the user hits accept or yes google will send auth code to the redirect url 
and then as we said the middle ware will catch that code first and will make reuqest to get access token wil the auth code 
after getting the access token will get all claims and put it in Context.User or Context.AuthenticateAsync(Schema)

and then will signin make cookie with that claims

so that is the bhavior of External Authentication with OAuth 

also there is an events that you can define 
and that events in spicifc sitiuation for exampel 
theere is an event you can make after the middelware creating the cookie and before making the cookie for example you want to store the user 

for example 

OnRedirectToAuthorizationEndpoint ->
means before the user arrives to google authentication you wanna add some logic

OnCreatingTicket -> 
means once the middleware have the token but before extracting the claims

OnTicketReceived -> 
after etracting the claims but before creating the cookie

OnRemoteFailure -> 
means when the OAuth failed for some reason Exception Handling 

OnAccessDenied -> 
i thing it clear 


so that simply the OAuth With Google

Again
Google OAuth Flow in ASP.NET Core
Key Concepts

HttpContext.User is populated from the cookie or token that arrives with the request.

SignInAsync() creates the cookie for future requests, not for the current one.

On the first request (e.g., signin-callback), HttpContext.User is usually null because the cookie hasn’t been sent back by the client yet.

Step-by-Step Flow

User clicks "Sign in with Google"

Your app redirects the user to Google using:

var properties = new AuthenticationProperties() { RedirectUri = "signin-callback" };
await ctx.ChallengeAsync(GoogleDefaults.AuthenticationScheme, properties);


Google Authentication

Google shows the login/consent UI.

User enters credentials and accepts.

Google sends an authorization code to the redirect URL (signin-callback).

Middleware Processing

OAuth middleware intercepts the request before it reaches your endpoint.

Middleware exchanges the authorization code for an access token (and ID token if available).

Middleware extracts claims from the access token.

Middleware creates a ClaimsPrincipal and stores it in context.User temporarily for the current middleware pipeline.

Middleware creates a cookie with these claims for future requests.

Current Request (signin-callback)

At this moment:

The cookie is not yet sent back by the client.

Therefore, HttpContext.User from the request is still null.

To access claims for this request, use the result from:

var result = await ctx.AuthenticateAsync(GoogleDefaults.AuthenticationScheme);
var principal = result.Principal;


Sign-in / Cookie Creation

If you want, you can explicitly call:

await ctx.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, principal);


This writes the cookie to the response for the next requests.

Redirect to Original URL

You can then redirect the user to the original page they wanted:

ctx.Response.Redirect(returnUrl ?? "/");


Subsequent Requests

On all subsequent requests:

The cookie is sent by the browser.

HttpContext.User is automatically populated from the cookie.

Claims are available for authorization, display, etc.

Events in OAuth

OnRedirectToAuthorizationEndpoint → Before sending the user to Google.

OnCreatingTicket → After getting the access token, but before extracting claims.

OnTicketReceived → After extracting claims, before creating cookie.

OnRemoteFailure → When OAuth fails for any reason.

OnAccessDenied → When the user denies access.

This gives you full control:

You can add custom logic when creating the cookie (OnTicketReceived).

You can log or store users in DB.

You can modify claims before signing in.s

==================




